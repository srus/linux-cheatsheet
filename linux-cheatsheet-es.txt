# ==============================================================================
#                          Notas sobre Linux y Bash
# ==============================================================================
#
#
# Bash [1]
# ====
#
# Algunas variables internas
# --------------------------
#
# - $0:             Nombre del script o de la shell.
# - $$:             PID del script o de la shell.
# - $BASHPID:       PID de la instancia de Bash. Si es un proceso hijo $$ y
#                   $BASHPID son distintos, siendo $$ el PID del padre.
# - $BASH_SUBSHELL: Indica si la instancia es una subshell.
# - $1, $2, ...:    Acceso por posición a los argumentos del script.
# - $_:             Último argumento recibido en el comando anterior.
# - $?:             Estado de salida del comando anterior.
#
# Variables y cadenas de caracteres
# ---------------------------------
#
# - Ejemplo de asignación de variable de entorno:
#       x="hello world"
#
# - Ejemplo de uso de variable:
#       echo "$x"
#
# - El carácter '`' (acento grave) permite ejecutar comandos dentro de
#   expresiones:
#
#       echo "`pwd`"
#       => /tmp/foo/bar
#
#       x="`pwd`"
#
# - Se pueden modificar variables de entorno específicamente para la ejecución
#   de un comando:
#
#       echo "`LANG=en date`"
#       => Wed Apr 15 17:19:53 CEST 2015
#
#       echo "`date`"
#       => mié abr 15 17:20:10 CEST 2015
#
# - El carácter '$' permite ejecutar comandos y manipular las variables de tipo
#   cadena de caracteres para usos diversos, como obtener la longitud de la
#   cadena, subcadenas, buscar y reemplazar cadenas, concatenar cadenas, etc.
#
#       echo "$(pwd)"
#       => /tmp/foo/bar
#
#       echo "$(pwd)ABC"
#       => /tmp/foo/barABC
#
#       Concatenación de cadenas: string1${var}string2
#           bar="bar"
#           echo "foo${bar}foo"
#           => foobarfoo
#
#       Longitud de cadena: ${var#}
#           x="hello world"
#           echo "${#x}"
#           => 11
#
#       Subcadena por posición: ${var:offset:length}
#           x="hello world"
#           echo "${x:1:6}"
#           => ello w
#           echo "${x:0:-3}"
#           => hello wo
#
#       Subcadena recortando por la cola: ${var%substring}
#           x="foo.png"
#           echo "${x%.png}"
#           => foo
#
#       Reemplazamiento de todas las ocurrencias: ${var//pattern/string}
#           x="hello world"
#           echo "${x//world/people}"
#           => hello people
#
#       Acceso a vector de cadenas: ${var[index]}
#           x=(hello world)
#           echo "${x[0]}"
#           => hello
#           echo "${x[1]}"
#           => world
#
#           Si `index` es '@' se accede a todas las cadenas:
#           x=(hello world)
#           echo "${x[@]}"
#           => hello world
#
# - Las comillas simples y dobles no son equivalentes. Con comillas dobles
#   algunos caracteres se interpretan como caracteres especiales:
#       $, `, {, }, +, (, ).
#   Esto permite evaluar variables y ejecutar comandos dentro de una expresión:
#
#       echo "$x"
#       => hello world
#
#       echo "`pwd`"
#       => /tmp/foo/bar
#
#   Con comillas simples todos los caracteres se interpretan como literales:
#
#       echo '$x'
#       => $x
#
#       echo '`pwd`'
#       => `pwd`
#
# - Para operar con variables y obtener una expresión, se usa el comando `expr`:
#       x=1
#       y=2
#
#       echo `expr $x + $y`
#       => 3
#
#       echo $x + $y
#       => 1 + 2
#
# Variables de entorno
# --------------------
#
# - Definir una variable de entorno:
#
#       FOO="bar"
#
#       echo $FOO
#       => bar
#
#   Esta variable estará disponible mientras el proceso esté activo.
#
# - Eliminar una variable de entorno:
#       unset FOO
#
# - Definir variables de entorno que sólo estén disponibles en la ejecución de
#   un comando:
#
#       FOO1="bar1" FOO2="bar2" <comando>
#
#       echo $FOO1
#       =>
#
# - Exportar variables de entorno desde un proceso hijo al padre y a los
#   procesos hermanos sucesivos (que aparecen a la derecha):
#
#       cat script1.sh
#       =>
#       export FOO="bar"
#
#       cat script2.sh
#       =>
#       echo $FOO
#
#       bash -c 'source ./script1.sh ; ./script2.sh ; echo $FOO'
#       => bar
#       => bar
#
#       sh -c '. ./script1.sh ; ./script2.sh ; echo $FOO'
#       => bar
#       => bar
#
#
#   El comando `source` sólo está disponible en Bash y es un alias de `.`, que
#   es un comando POSIX disponible en sh. Sirve para ejecutar un script en el
#   entorno de la shell, de forma que las variables creadas o modificadas en
#   el script siguen disponibles en la shell cuando el script termina de
#   ejecutarse.
#
# Ejecución de comandos
# ---------------------
#
# - Bash permite agrupar comandos [2] para tratarlos como una unidad, haciendo
#   por ejemplo que devuelvan una salida única:
#
#       - Si la agrupación se hace con paréntesis, los comandos se ejecutan en
#         una subshell:
#
#             (echo $$ $BASHPID $BASH_SUBSHELL)
#             =>
#             1200 5123 1
#
#             (echo $$ ; echo $BASHPID ; echo $BASH_SUBSHELL)
#             =>
#             1200
#             6267
#             1
#
#       - Si la agrupación se hace con llaves, los comandos se ejecutan en el
#         mismo contexto (mismo proceso que la shell):
#
#             { echo $$ ; echo $BASHPID ; echo $BASH_SUBSHELL ; }
#             =>
#             1200
#             1200
#             0
#
#         Nota: Al usar llaves es obligatorio escribir ';' al final de la lista
#         de comandos y separar las llaves con espacios.
#
# - El comando `set` permite configurar opciones de la shell. Por ejemplo, es
#   recomendable añadir al comienzo del script la opción `set -u`, que sirve
#   para tratar las variables no definidas como un error, evitando errores
#   silenciosos. Otra opción que puede ser útil es `set -e`, para interrumpir
#   la ejecución del script cuando algún comando devuelva un valor distinto de
#   0 (0 indica éxito). El problema es que puede haber comandos que de forma
#   intencionada devuelvan un valor distinto de 0. Por ello es recomendable
#   evitar el uso de `set -e` y realizar las comprobaciones de errores
#   manualmente por cada comando, por ejemplo siguiendo este patrón:
#
#       <comand> || { echo "error"; exit 1; }
#
#   Otra opción muy usada es `set -o pipefail`, para devolver siempre un valor
#   distinto de 0 si falla algún comando usando tuberías. [4]
#
#
# Redireccionamiento de entrada/salida [3]
# ------------------------------------
#
# - Por defecto existen tres archivos abiertos siempre disponibles:
#       stdin (entrada estándar)
#       stdout (salida estándar)
#       stderr (errores)
#
#   cuyos descriptores de archivo son respectivamente:
#       0
#       1
#       2
#
# - Los archivos, comandos, programas y scripts se pueden redireccionar
#   mediante operadores:
#
#       - Redireccionar la salida de un comando a un archivo, sobreescribiendo
#         o creándolo si no existiera:
#
#             <command> > <file>
#
#       - Redireccionar la salida de un comando a un archivo, concatenando o
#         creándolo si no existiera:
#
#             <command> >> <file>
#
#       - Redireccionar un archivo como entrada de un comando:
#
#             <command> < <file>
#
#             También se puede usar como entrada la salida de un comando
#             usando una subshell (ver arriba cómo agrupar comandos):
#
#                 <command1> <(<command2>)
#
#             Ejemplo:
#                 shuf <(seq 3)
#                 => 1 3 2
#
#       - Redireccionar stdout de un comando a otro:
#
#             <command1> | <command2> | <command3>
#
#       - Redireccionar stdout y stderr de un comando a otro:
#             <command1> |& <command2>
#
#             Equivalente a redireccionar stderr a stdout en el primer comando:
#                 <command1> 2>&1 | <command2>
#
# - Los comandos usan por defecto los archivos stdin, stdout y sdterr para la
#   entrada/salida. Esto se puede modificar en cada ejecución:
#
#       - Redireccionar stdout a un archivo:
#
#             <command> 1> <file>
#
#       - Redireccionar stderr a un archivo:
#
#             <command> 2> <file>
#
#       - Redireccionar stdout y stderr a un archivo:
#
#             <command> &> <file>
#
#       - Redireccionar stdout a un archivo y stderr a la salida estándar (esto
#         es equivalente a la redirección anterior):
#
#             <command> 1> <file> 2>&1
#
#             En general cualquier descriptor de archivo 'i' se puede
#             redireccionar a otro 'j':
#
#                 i>&j
#
#             Si no se indica nada, por defecto se usa el descriptor 1
#             (stdout):
#
#                 >&j
#
#
# Información y configuración del sistema
# =======================================
#
# Descripción de la jerarquía del sistema de archivos:
#     man hier
#
# Versión del kernel:
#     uname -a
#
# Parámetros de configuración del kernel:
#     sysctl -a
#
# Info de la distribución:
#     lsb_release -a
# O bien:
#     cat /etc/issue
#
# Info de la CPU:
#     lscpu
#
#     O bien:
#         cat /proc/cpuinfo
#
# Mostrar número de núcleos de procesador disponibles:
#     nproc
#
# Info del hardware:
#     sudo lshw
#
# Info de la memoria:
#     sudo dmidecode --type memory
#
# Info de la batería (incluido temperatura)
#     acpi -V
#
# Info de dispositivos PCI:
#     lspci
#
# Info de memoria ocupada:
#     free -mt
#
# Info de memoria ocupada (en detalle):
#     cat /proc/meminfo
#
# Info sobre dispositivos y espacio ocupado en el sistema de archivos:
#     df
#
# Info de la tarjeta gráfica:
#     sudo lshw -C video
#
# Info sobre voltajes, temperaturas y velocidad de ventiladores:
#     sensors
#
# Límites de uso de recursos por parte del usuario:
#     ulimit -a
#
# Mostrar los modos de rendimiento disponibles del procesador:
#     cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors
#
# Mostrar el modo actual de rendimiento del procesador:
#     cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
#
#     Para cambiar el modo del procesador de forma permanente hay que modificar
#     el archivo:
#         `/etc/sysfs.conf`
#
#     Y añadir la línea:
#         `devices/system/cpu/cpu0/cpufreq/scaling_governor=<modo_cpu>`
#
#     Nota: Es necesario tener instalado el paquete "sysfsutils".
#
# Info de los dispositivos de red instalados:
#     iwconfig
#
# Escanear redes con el dispositivo wifi "eth_n" (para n = 0, 1, 2, ...):
#     iwlist <eth_n> scan
#
# Apagar la antena wifi:
#     sudo iwconfig <eth_n> txpower off
#
# Comprobar el rendimiento de la tarjeta gráfica:
#     glxgears -printfps
#
# Configuración del color (RGB):
#     xgamma
#
#
# Administración del sistema
# ==========================
#
# Salir de la shell:
#     exit ó <Ctrl + D>
#
# Mostrar la ayuda de Bash:
#     help [<command>]
#
# Buscar un comando en el historial de bash:
#     <CTRL> + R + <command>            # avanzar
#     <CTRL> + <SHIFT> + R + <command>  # retroceder
#
# Eliminar línea actual en la shell:
#     <CTRL> + U
#
# Eliminar palabra actual en la shell:
#     <CTRL> + W
#
# Mostrar todos los manuales donde aparezca la palabra "crontab":
#     man -k crontab
#
#     Si hay varios manuales que se llaman "crontab", mostrar aquel con
#     identificador igual a 5:
#         man 5 crontab
#
# Moverse al directorio $HOME:
#     cd
#
# Moverse al directorio en que se estaba antes:
#     cd -
#
#     Ejemplos:
#
#         pwd
#         => /tmp/foo/
#
#         cd ../bar && pwd && cd -
#         => /tmp/bar/
#         => /tmp/foo/
#
#         pwd
#         => /tmp/foo/
#
# Ver qué usuarios han iniciado sesión:
#     who
#
# Ver qué usuarios han iniciado sesión y qué están haciendo:
#     w
#
# Convertirse en root modificando el entorno (environment):
#     sudo -i  # `logout` para dejar de serlo
#
# Convertirse en root SIN modificar el entorno (environment):
#     sudo -s  # `logout` para dejar de serlo
#
# Iniciar sesión como otro usuario.
#     sudo su <username>
#
#     Si el usario actual es root, también se puede usar el comando "su":
#         su <username>
#
# Ejecutar un comando como otro usuario:
#     sudo -u [<username>] <command>
#
#     Si el usario actual es root, también se puede usar el comando "su":
#         su -c <command> <username>
#
# Forzar reinicio de Linux (para casos extremos):
#     <ALT> + <IMPR. PANTALLA> + escribir REISUB
#
# Reiniciar las X (servidor gráfico):
#     <ALT> + <IMPR. PANTALLA> + K
#
#     O bien:
#         <ALT> + <CTRL> + retroceso
#
# Mostrar el estado de un servicio del sistema:
#     service <service_name> status
#
#    Con systemd:
#        systemctl [--user] status <service_name>
#
# Mostrar el estado de todos los servicios del sistema:
#     service --status-all
#
# Iniciar un servicio del sistema:
#     sudo service <service_name> start
#
#     Con systemd:
#         systemctl [--user] start <service_name>
#
# Parar un servicio del sistema:
#     sudo service <service_name> stop
#
#     Con systemd:
#         systemctl [--user] stop <service_name>
#
#
# Activar un servicio del sistema en el arranque:
#     sudo update-rc.d <service_name> defaults
#
#     Con systemd:
#         systemctl [--user] enable <service_name>
#
# Desactivar un servicio del sistema en el arranque:
#     sudo update-rc.d <service_name> disable
#
#     Con systemd:
#         systemctl [--user] disable <service_name>
#
# Comprobar sectores defectuosos en un disco en modo no-destructivo:
#     badblocks -nsv /dev/<device>
#
# Comprobar y reparar el sistema de archivos:
#     fsck -V /dev/<device>
#
# Medir el uso de recursos de un programa:
#     /usr/bin/time [-v] <command>
#
#     Nota:
#     Bash incluye por defecto el comando `time`, pero muestra una información
#     mucho más resumida que la anterior:
#         time <command>
#
# Vaciar los buffers de memoria y guardarlos en disco. El kernel de Linux
# almacena en memoria RAM datos para minimizar las lecturas/escrituras de
# disco, mucho más lento. Para evitar posibles pérdidas de datos, se puede
# obligar al kernel a que guarde estos buffers en el disco duro:
#     sync
#
# Mostrar información sobre un comando:
#     type <comando>

#     Ejemplos:
#         type mv:
#         => mv is hashed (/bin/mv)

#         type ls:
#         => ls is aliased to `ls --color=auto'

#         type source:
#         => source is a shell builtin

#         type .:
#         => . is a shell builtin

#         type cd:
#         => cd is a function
#            cd ()
#            {
#                __zsh_like_cd cd "$@"
#            }
#
#
# Procesos
# ========
#
# Mostrar todos los procesos:
#     ps -ef
#
# Mostrar todos los procesos con información ampliada (CPU, MEM, etc):
#     ps aux
#
# Mostrar procesos en ejecución de un comando:
#     ps u -C <command>
#
# Mostrar los procesos en forma de árbol:
#     pstree
#
# Ejecutar un comando y enviarlo a segundo plano:
#     <comand> &
#
# Mostrar procesos detenidos o enviados a segundo plano:
#     jobs
#
# Reactivar un proceso detenido o enviado a segundo plano y enviarlo a
# primer plano:
#     fg [<job_id>]
#
# Reactivar un proceso detenido y enviarlo a segundo plano:
#     bg [<job_id>]
#
# Pausar un proceso:
#     kill -STOP <pid> o <Ctrl + Z> si es el proceso actual
#
# Reactivar un proceso:
#     kill -CONT <pid>
#
# Terminar un proceso de forma controlada:
#     kill [-TERM] <pid>
#
# Interrumpir el proceso actual:
#     kill -INT <pid> o <Ctrl + C> si es el proceso actual
#
# Matar un proceso:
#     kill -KILL <pid>
#
# Matar un proceso a partir del nombre:
#     killall <nombre_proceso>
#
# Parar los procesos zombies hijos de un proceso:
#     kill -CHLD <pid_padre>
#
# Matar el cliente gráfico (servidor X) de un proceso:
#     xkill
#
#     Nota:
#     Esta utilidad sólo cierra la conexión con el servidor X, lo que provoca
#     que la mayoría de comandos se cierren también, aunque algunos pueden no
#     cerrarse (ver `man xkill`).
#
# Ejecutar comando inmune a señal SIGHUP (logout). Útil para ejecutar comando
# en background en servidor remoto. Por defecto la salida estándar se
# redirecciona a `./nohup.out` o `$HOME/nohup.out`:
#     nohup <command> >> <output> &
#
#     Alternativas similares a este comando: tmux y screen.
#
# Pasar la salida de un comando como argumentos a otro comando. Útil cuando
# un comando no permite leer desde la entrada estándar o desde archivos. Otra
# ventaja de `xargs` es que limita automáticamente el número de argumentos
# al máximo permitido por el comando:
#
#     <comando1> | xargs <comando2>
#
#     Ejemplo:
#         cat dirs.txt
#         =>
#         dir1
#         dir2
#         dir3
#
#         cat dirs.txt | xargs mkdir
#
#         ls
#         => dir1  dir2  dir3  dirs.txt
#
#     `xargs` no es capaz de procesar archivos que contienen en el nombre
#     saltos de línea (\n) o espacios en blanco (por defecto se toma como
#     separador el salto de línea). Para evitar esto se usa la opción "-0",
#     que indica que en la entrada se usa el carácter "null" (\0) como
#     separador. También hace que los caracteres '"' y '\' no se traten como
#     caracteres especiales. Algunos comandos (como `find`) permiten modificar
#     la salida para usar como separador el carácter "null" (\0).
#
#         Ejemplos:
#
#         Eliminar los directorios encontrados con `find`:
#             find / -type d -iname '*dirname*' -print0 | xargs -0 rmdir
#
#         Listar el contenido de los directorios encontrados con `find`:
#             find / -type d -iname '*dirname*' -print0 | xargs -0 ls -l
#
#     `xargs` también permite realizar sustituciones de cadenas a partir de la
#     entrada estándar:
#
#         <command1> | xargs -I <str_repl> <command2> <str_repl>
#
#         Ejemplo:
#             echo foobar | xargs -I "%" echo "msg: %, %"
#             => msg: foobar, foobar
#
#     `xargs` permite lanzar varios procesos en paralelo, para usar varios
#     núcleos del procesador:
#
#         <command> | xargs -P <max_proc>
#
#         Si <max_proc> es 0, se permite usar todos los núcleos disponibles.
#
#     A diferencia de GPU Parallel, `xargs` sólo permite ejecutar 1 comando.
#     Si se requieren más comandos, es necesario ejecutar el script desde un
#     archivo o desde una cadena de caracteres con la opción `-c` de Bash:
#
#         <command> | xargs bash -c '<script_body>'
#
# Copiar la entrada estándar en archivos y en la salida estándar al mismo
# tiempo. Útil para guardar una copia en disco de la salida de un comando:
#     <command1> | tee [-a|--append] <file> | <command2>
#
#     Ejemplo:
#         seq 3 | tee numbers.txt | wc -l
#
#
# Permisos
# ========
#
# Dar permisos de ejecución a un archivo:
#     chmod u+x <file>
#
# Cambiar los permisos del contenido de un directorio recursivamente:
#     sudo chmod 755 -R <path>
#
# Cambiar el propietario del contenido de un directorio. Con "-R" para hacerlo
# recursivamente:
#     sudo chown [-R] <username> <path>
#
# Cambiar el grupo del contenido de un directorio. Con "-R" para hacerlo
# recursivamente:
#     sudo chown [-R] :<groupname> <path>
#
# Cambiar el propietario y grupo del contenido de un directorio recursivamente:
# Con "-R" para hacerlo recursivamente:
#     sudo chown [-R] <username>:<groupname> <path>
#
# Hacer que un usuario (con permiso de ejecución) herede temporalmente los
# privilegios del propietario de un archivo ejecutable:
#     chmod u+s <path>
#
# Hacer que un usuario (con permiso de ejecución) herede temporalmente los
# privilegios del grupo de un archivo ejecutable:
#     chmod g+s <path>
#
#     Ejemplos:
#
#     Queremos que todos los usuarios puedan ejecutar el comando "foobar"
#     (ficticio). Supongamos que este ejecutable tiene permiso de ejecución
#     para todos los usuarios, pero dado que necesita acceder a un archivo de
#     configuración del sistema (foobar.conf), sólo el usuario "root" tiene
#     privilegios suficientes para hacerlo. Solución:
#
#         - Crear el grupo "foobar".
#         - Cambiar el grupo de dicho archivo de configuración:
#               sudo chown :foobar <path>/foobar.conf
#         - Cambiar el grupo del ejecutable:
#               sudo chown :foobar <path>/foobar
#         - Cambiar el bit SGID del ejecutable:
#               sudo chmod g+s <path>/foobar
#
#    A partir de ahora cualquier usuario que ejecute "foobar" heredará los
#    privilegios del grupo "foobar", y con ello podrá acceder a "foobar.conf".
#
# Mantener el mismo grupo del directorio en toda la jerarquía de archivos y
# directorios que se creen dentro:
#     chmod g+s <path>
#
# Comprobar si un usuario existe en el sistema:
#     grep -i '<username>' /etc/passwd
#
# Comprobar si un grupo existe en el sistema:
#     grep -i '<groupname>' /etc/group
#
# Añadir un usuario:
#     sudo adduser <username>
#
# Añadir un grupo:
#     sudo groupadd <groupname>
#
# Eliminar un usuario:
#     sudo deluser <username>
#
# Eliminar un grupo:
#     sudo delgroup <groupname>
#
# Añadir un usuario a un grupo:
#    sudo gpasswd -a <username> <groupname>
# O bien:
#    sudo usermod -a -G <groupname> <username>
#
# Permitir que un usuario normal pueda manejar un servicio del sistema:
#     Abrir el archivo "sudoers" con `sudo visudo` y añadir:
#         <username>        ALL=/etc/init.d/<service_name>
#
#
# Archivos y directorios
# ======================
#
# Mostrar la ruta actual:
#     pwd
#
# Mostrar la ruta al directorio padre de la ruta actual:
#     dirname "`pwd`"
#
# Mostrar el nombre del directorio de la ruta actual:
#     basename "`pwd`"
#
# Ver el contenido de un directorio:
#     ls <path>
#
#     O bien: l <path>
#
#     Nota:
#     Con `l` los directorios, binarios y enlaces se muestran en otro formato.
#
# Ver el contenido de un directorio en detalle (sin archivos ni directorios
# ocultos):
#     ls -l <path>
#
#     Nota:
#     Con la opción `-h` muestra el tamaño en un formato más legible (KB,
#     MB, GB).
#
# Ver el contenido de un directorio en detalle (con archivos y directorios
# ocultos):
#     ls -la <path>
#
#     O bien: ll <path>
#
#     Nota:
#     Con `ll` los directorios, binarios y enlaces se muestran en otro formato.
#
# Ver el contenido de un directorio en forma de árbol:
#     tree -L <deep_level>
#
# Ver el tamaño total de un directorio:
#     du -h -d 0 <path>
#
# Ver el tamaño del contenido de un directorio:
#     du -h -d 1 <path>
#
# Copiar un archivo en la misma ruta de origen añadiendo un sufijo al nombre:
#     cp <path>{,sufix}
#
#     Ejemplo:
#         cp tmp/file.txt{,.tmp}
#         ls tmp
#         => file.txt file.txt.tmp
#
# Buscar archivos por nombre usando la base de datos del sistema:
#     locate <filename>
#
#     Nota:
#     Probablemente no funcionará con archivos creados recientemente, ya que
#     Linux no habrá tenido tiempo de actualizar la base de datos del sistema,
#     lo cual se hace con una tarea cron diariamente.
#
# Buscar archivos y directorios mediante una expresión regular:
#     find <path> '<pattern>'
#
#     En `find` las opciones se van aplicando como una sucesión de filtros, por
#     lo que el orden de las opciones es importante.
#
#     Con la opción `-iname` busca sin sensibilidad a mayúsculas:
#         find <path> -iname '<pattern>'
#
#     Con la opción `!` o `-not` busca lo contrario:
#         find <path> {!,-not} -iname '<pattern>'
#
#     Con la opción `-a` o `-and` busca todos los patrones:
#         find <path> -iname '<pattern1>' {-a,-and} -iname '<pattern2>'
#
#     Con la opción `-o` o `-or` busca alguno de los patrones:
#         find <path> -iname '<pattern1>' {-o,-or} -iname '<pattern2>'
#
#     Con la opción `-type f` busca sólo archivos:
#         find <path> -type f -iname '<pattern>'
#
#     Con la opción `-type d` busca sólo directorios:
#         find <path> -type d -iname '<pattern>'
#
#     Con la opción `-mtime` busca según la fecha de modificación:
#         find <path> -mtime [+]<num_days>
#
#         Buscar archivos modificados hace 5 días:
#             find <path> -mtime 5
#
#         Buscar archivos modificados en los últimos 5 días:
#             find <path> -mtime +5
#
#     El comando `find` se puede combinar con `exec` para ejecutar comandos
#     sobre los archivos encontrados:
#         find <path> -exec <command> '{}' ';'
#
#     Buscar por propietario y grupo:
#         find <path> -user '<user_name>'
#         find <path> -group '<group_name>'
#
#     Buscar enlaces duros:
#         find <path> -type f -links <n>
#
#         donde <n> puede ser:
#             n: exactamente n links
#             +n: más de n links
#             -n: menos de n links
#
#     Buscar archivos modificados en los últimos 100 días y eliminarlos:
#         find <path> -type f -mtime +100 -exec rm '{}' ';'
#
#     Otra forma de buscar y eliminar archivos es con la opción `-delete`. ¡OJO!
#     hay que ponerla siempre al final! ¡Si se pusiera al principio iría
#     eliminando TODOS los archivos y directorios que fuera encontrando!
#         find <path> -type f -iname '<pattern>' -delete
#
#     Con la opción `-print0` se cambia en la salida el carácter "salto de
#     línea" (\n) por el carácter "null" (\0). Ojo, esta opción se añade
#     siempre al final.
#
# Comprimir en gzip:
#     gzip -c <in_file> > <out_file>
#
# Descomprimir gzip:
#     gunzip -c <in_file> > <out_file>
#
# Comprimir en zip:
#     zip -r <zip_name> <file_or_directory>
#
# Descomprimir zip:
#     unzip <zip_file> -d <output_dir>
#
# Comprimir en tar.gz:
#     tar -zcvf <filename.tar.gz> <filename>
#
# Descomprimir tar.gz (manteniendo los permisos):
#     tar -zxpf <filename.tar.gz>
#
# Empaquetar en tar:
#     tar -cvf <filename.tar> <filename>
#
# Desempaquetar tar:
#     tar -xpf <filename.tar>
#
# Crear enlace simbólico:
#     ln -s <origin_path> <linkname>
#
# Crear enlace duro:
#     ln <origin_path> <linkname>
#
# Eliminar archivo de forma segura:
#     shred -u -z -n 20
#
# Comprobar si un archivo es un archivo regular (devuelve 0 en caso de éxito ó
# 1 en caso contrario):
#     test -f <file>
#
# Comprobar si un archivo es un directorio (devuelve 0 en caso de éxito ó 1 en
# caso contrario):
#     test -d <file>
#
# Ejecutar un comando sobre un archivo cuyo nombre comienza por '-':
#     <command> ./<filename>
#
#
# Archivos de texto
# =================
#
# Buscar las ocurrencias de `keyword`:
#     grep '<keyword>' <file>
#
# Buscar las ocurrencias que NO contengan `keyword`:
#     grep -v '<keyword>' <file>
#
# Buscar sin distinguir mayúsculas/minúsculas:
#     grep -i '<keyword>' <file>
#
# Buscar las ocurrencias que contengan `keyword1` o `keyword2`:
#     egrep '<keyword1>|<keyword2>' <file>
#
#     Nota: `egrep` es equivalente a `grep -E`.
#
#     Con `-E` (de "Extended mode") indicamos a grep que use el símbolo "|"
#     como un operador, evitando tener que escaparlo. Lo mismo ocurre con el
#     resto de meta-caracteres: {, }, (, ), ?, +.
#
# Buscar las ocurrencias que comienzan por `keyword1` o `keyword2`:
#     egrep '^(keyword1|keyword2)' <file>
#
# Buscar las ocurrencias que terminan por `keyword1` o `keyword2`:
#     egrep '(keyword1|keyword2)$' <file>
#
# Buscar las ocurrencias de "keyword" mostrando sólo las ocurrencias,
# sin el contexto:
#     grep -o '<keyword>' <file>
#
# Añadir algunas líneas de contexto en las ocurrencias encontradas:
#     grep -C <NUM> '<pattern>' <file>
#
# Buscar texto leyendo el patrón desde un archivo:
#     grep -f <patterns_file> <file>
#
# Buscar texto en archivos de un directorio recursivamente:
#     rgrep '<pattern>' <path>
#
#     `rgrep` es equivalente a `grep -r`.
#
# Utilidad basada en grep para buscar en archivos comprimidos:
#     zgrep
#
#     Ejemplo: zgrep 'foobar' /path/to/folder/log*.gz
#
# Numerar las líneas de un archivo:
#     cat -n <file>
#
# Mostrar las primeras N líneas de un archivo:
#     head -n N <file>
#
# Mostrar todas las líneas de un archivo excepto las N últimas:
#     head -n -N <file>
#
# Mostrar las últimas N líneas de un archivo:
#     tail -n N <file>
#
# Mostrar todas las líneas de un archivo excepto las N primeras:
#     tail -n +N <file>
#
# Mostrar el contenido de un archivo conforme se va modificando:
#     tail -f <file>
#
# Buscar expresion regular en un archivo abierto con less (también sirve en
# man, ya que está basado en less):
#     /<pattern>
#
#     A continuación pulsar `n` para saltar a la siguiente ocurrencia o
#     `shift + n` para saltar hacia atrás.
#
# Transformar/filtrar texto desde archivos o desde la entrada estándar:
#     sed [-i] "<pattern>" <files>
#
#     Con la opción `-i` se escribe en los archivos de entrada. Por defecto se
#     escribe en la salida estándar.
#
#     Nota: El programa sed está disponible en diferentes versiones (GNU/Linux,
#     UNIX/MacOS) y no son equivalentes: algunos parámetros no están disponibles
#     o tienen distinto significado. Una de las alternativas a sed es Perl.
#
#     Ejemplos:
#
#         Sustituir la primera ocurrencia de "bar" por "cow":
#             echo "foo bar zoo bar" | sed "s/bar/cow/"
#             =>
#             foo cow zoo bar
#
#             Con Perl:
#                 perl -p -e "s/bar/cow/"
#                 =>
#                 foo cow zoo bar
#
#         Sustituir todas las ocurrencias de "bar" por "cow":
#             echo "foo bar zoo bar" | sed "s/bar/cow/g"
#             =>
#             foo cow zoo cow
#
#             Con Perl:
#                 perl -p -e "s/bar/cow/g"
#                 =>
#                 foo cow zoo cow
#
#         Ejemplo anterior pero usando un archivo:
#             sed -i "s/bar/cow/g" myfile.txt
#
#             Con Perl:
#                 perl -i -p -e "s/bar/cow/g" myfile.txt
#
#         Sustituir todas las ocurrencias de "my_path" por el resultado de `pwd`
#         en todos los archivos con extensión ".txt" de un directorio:
#             p="`pwd`"
#             p="${p//\//\\/}"  # escapa todas las barras
#             sed -i "s/my_path/$p/g" *.txt
#
#         Escapar espacios en blanco de un archivo con nombres de directorios y
#         crear dichos directorios:
#             sed "s/\ /\\\ /g" dirs.txt | xargs -I % mkdir "%"
#
# Sustituir todas las ocurrencias de "my_path" por el resultado de `pwd`
# recursivamente (-R) en todos los archivos con extensión ".txt" (-x) de un
# directorio, sin cambiar las fechas de modificación (-d):
#     rpl -Rd -x'.txt' 'my_path' "`pwd`" <dir_path>
#
#     Nota: Es necesario tener instalado el paquete "rpl".
#
# Filtrar columnas de un texto tabulado con espacios o tabuladores:
#     awk '{print $<column_number>}' <file>
#
#     Ejemplo:
#
#     Mostrar el PID de todos los procesos del usuario "sergio":
#         ps -ef | grep sergio | awk '{print $2}'
#         =>
#         3134
#         3145
#         ...
#
# Filtrar columnas de un texto tabulado usando un delimitador específico:
#     cut -d <delimiter> -f <columns_range> <file>
#
#     Ejemplos:
#
#     Mostrar columnas desde la segunda en adelante:
#         cut -d ' ' -f 2- <file>
#
#     Mostrar sólo la primera columna:
#         cut -d ' ' -f 1 <file>
#
# Filtrar sólo los caracteres que aparecen en un rango de posiciones:
#     cut -c <positions_range> <file>
#
#     Ejemplos:
#
#     Suponiendo un archivo de texto con el siguiente contenido:
#         foo:bar:baz:qux:quux
#         one:two:three:four:five:six:seven
#         alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
#         the quick brown fox jumps over the lazy dog
#
#     Filtrar sólo los caracteres que aparecen entre la posición 4 y 10:
#         cut -c 4-10 <file>
#         =>
#         :bar:ba
#         :two:th
#         ha:beta
#          quick
#
#     Filtrar sólo los caracteres que aparecen hasta la posición 4:
#         cut -c -4 <file>
#         =>
#         :bar
#         one:
#         alph
#         the
#
#     Filtrar sólo los caracteres que aparecen en la posición 1:
#         cut -c 1 <file>
#         =>
#         :
#         o
#         a
#         t
#
# Eliminar caracteres:
#     echo "ab123" | tr -d 'abc'
#     => 123
#
# Eliminar líneas repetidas:
#     uniq <file> [-c]
#
#     El parámetro '-c' añade el número de ocurrencias de cada línea.
#
# Concatenar el contenido de varios archivos y mostrarlo por la salida
# estándar:
#     tac <file1> <file2>
#
# Ordenar las líneas de un archivo:
#     sort <file> [-n]
#
#     El parámetro '-n' sirve para comparar numéricamente.
#
# Ordenar aleatoriamente las líneas de un archivo:
#     shuf <input_file> > <output_file>
#
# Concatenar dos archivos línea a línea usando un delimitador:
#     paste -d '=' list1.txt list2.txt
#
# Generar archivo diff a partir de las diferencias entre todos los archivos de
# dos directorios:
#     diff -ur <old_directory> <new_directory> > changes.diff
#
# Ver diferencias entre archivos:
#     comm -12 <file1> <file2>
#
# Ver diferencias entre archivos en color:
#     colordiff <file1> <file2>
#
#     Nota: Es necesario tener instalado el paquete "colordiff".
#
# Aplicar parche a los archivos de un directorio a partir de un archivo diff:
#     patch -p1 -N -d <old_directory> < changes.diff
#
# Redirección de archivos. Descriptores básicos del sistema:
#
#     0 standard input
#     1 standard output
#     2 standard error
#
#     Ejemplo:
#         ./my_script.sh > /dev/null 2>&1
#
#     El carácter '&' sirve para identificar a "1" como un descriptor de
#     archivo (en este caso la salida estándar). En esa línea, "my_script.sh"
#     se está redirigiendo a "/dev/null" y los errores (stderr) a la salida
#     estándar (stdout).
#
#     Ejemplo:
#         ./my_script.sh 2> errors.log
#
#     Ahora sólo se están redirigiendo los errores a "errors.log".
#
#
# Redes / Internet
# ================
#
# Información de dispositivos de red instalados:
#     ip addr
#
# Información de tablas de enrutamiento:
#     ip route
#
# Conexión SSH por puerto estándar:
#     ssh <username>@<host>
#
# Conexión SSH por puerto específico:
#     ssh -p <port> <username>@<host>
#
# Copiar archivos desde el host local a un host remoto:
#     scp <origin_file> <username>@<host>:<destination_file>
#
# Copiar archivo desde un host remoto al host local:
#     scp <username>@<host>:<origin_file> <destination_file>
#
# Copiar archivo desde local a remoto usando certificado (pem):
#     scp -i <pem_file> <origin_file> <username>@<host>:<destination_file>
#
# Copiar directorio desde local a remoto:
#     scp -r <origin_dir> <username>@<host>:<destination_dir>
#
# Descargar archivo desde una URL:
#     wget <URL>
#
# Continuar descarga:
#     wget -c <URL>
#
# Descargar archivos a partir de un txt:
#     wget -i <list.txt>
#
# Descargar página e imprimir por salida estándar (-O -) en modo "quiet" (-q,
# sin imprimir mensajes de wget).
#
#     Nota:
#     En wget el símbolo '-' identifica a la salida estándar.
#         wget -q -O - <URL>
#
#     Aunque normalmente se escribe como:
#         wget -qO- <URL>
#
# Descargar una web completa:
#     wget --recursive --no-parent --page-requisites --user-agent Mozilla <URL>
#
# Mostrar conexiones TCP (-t) y UDP (-u) sin resolver los nombres de dominio
# (-n) de los programas (-p) que están actualmente escuchando (-l). Para
# refrescar continuamente usar la opción "-c":
#     netstat -t -u -l -n -p
#
# Mostrar en qué puerto está escuchando un servicio:
#     netstat -a | grep -i <service>
#
# Mostrar qué servicio está escuchando en un puerto:
#     lsof -i :<port>
#
# Comprobar puertos abiertos y servicios en ejecución de un servidor:
#     nmap -A -T4 <server>
#
# Comprobar intentos de entrada denegados por DenyHosts:
#     cat /etc/hosts.deny
#
#     Es necesario instalar el paquete "denyhosts".
#
# Mostrar la ruta que sigue un paquete por la red hasta llegar a un servidor:
#     traceroute <hostname>
# Nota: es necesario instalar el paquete "traceroute".
#
# Consultar a los servidores DNS información sobre un dominio:
#     dig [@<dns_server>] <domain>
#
#     Ejemplos:
#
#     Consultar al servidor de dominios 8.8.4.4 información sobre google.com:
#         dig @8.8.4.4 google.com
#
#     Consultar al servidor DNS por defecto (localizado en /etc/resolv.conf):
#         dig google.com
#
# Mostrar la traza para resolver un dominio:
#     dig +trace <domain>
#
# Consultar a los servidores DNS el dominio asociado a una IP:
#     dig -x <IP>
#
# Otra herramienta para consultar información de servidores DNS:
#     host [-d] <domain | IP>
#
#     Con el parámetro opcional '-d' muestra más información.
#
#     Ejemplo:
#         host 66.249.90.77
#         =>
#         77.90.249.66.in-addr.arpa domain name pointer rate-limited-proxy-66-249-90-77.google.com.
#
#         host rate-limited-proxy-66-249-90-77.google.com
#         =>
#         rate-limited-proxy-66-249-90-77.google.com has address 66.249.90.77
#
# Capturar tráfico de paquetes TCP:
#     sudo tcpdump -A -vvvv -s 9999 -i <interface> port <port> > tcp.log
#
# Cortafuegos (iptables)
# ----------------------
#
# Listar todas las reglas:
#     sudo iptables -L [chain]
#
#     Ejemplo:
#         Listar las reglas de la cadena INPUT:
#             sudo iptables -L INPUT
#
# Permitir el tráfico entrante en la cadena INPUT:
#     sudo iptables -A INPUT [-s IP] [-p <protocol>] [--dport <dest_port>] [-i <interface>] -j ACCEPT
#
#     Ejemplo (permitir tráfico TCP en el puerto por defecto de SSH):
#         sudo iptables -A INPUT -p tcp --dport ssh -j ACCEPT
#
#     Ejemplo (permitir tráfico TCP en el puerto 80):
#         sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
#
# Bloquear (sin responder al emisor) el tráfico entrante en la cadena INPUT:
#     sudo iptables -A INPUT [-s IP] [-p <protocol>] [--dport <dest_port>] [-i <interface>] -j DROP
#
#     Nota:
#     En iptables las reglas están ordenadas por orden de inserción y las que se
#     añadieron antes tienen preferencia sobre las posteriores.
#
#     Ejemplo (bloquear todo el tráfico entrante):
#         sudo iptables -A INPUT -j DROP
#
#     Ejemplo (bloquear tráfico en las cadenas INPUT y FORWARD para una
#     determinada IP origen):
#         sudo iptables -A INPUT -s <IP> -j DROP
#         sudo iptables -A FORWARD -s <IP> -j DROP
#
# Insertar una regla en una posición determinada en la cadena INPUT:
#     sudo iptables -I INPUT <position> [-p <protocol>] [--dport <dest_port>] [-i <interface>] -j <target>
#
#     Ejemplo (insertar en primera posición una regla para permitir tráfico
#     entrante en la interfaz loopback. De esta manera nos aseguramos que no
#     podemos bloquear posteriormente esta interfaz fundamental para el correcto
#     funcionamiento de muchos programas):
#         sudo iptables -I INPUT 1 -i lo -j ACCEPT
#
# Eliminar todas las reglas de iptables (restableciendo primero la política por
# defecto de las tres cadenas principales):
#     sudo iptables -P INPUT ACCEPT
#     sudo iptables -P OUTPUT ACCEPT
#     sudo iptables -P FORWARD ACCEPT
#     sudo iptables -F
#
# Activar ufw (interfaz de iptables):
#     sudo ufw enable
#
# Desactivar ufw (interfaz de iptables):
#     sudo ufw disable
#
# Ver el estado de ufw (interfaz de iptables):
#     sudo ufw status verbose
#
# Cambiar la política por defecto de ufw (interfaz de iptables) para permitir
# todas las conexiones entrantes (por defecto se permiten sólo conexiones
# salientes):
#     sudo ufw default allow incoming
#
# Limitar en ufw (interfaz de iptables) el número de intentos de entrada
# fallidos vía SSH. Por defecto bloquea cualquier IP que realice >= 6 intentos
# de entrada fallidos en los últimos 30 s:
#      sudo ufw limit ssh
#
#
# Instalación/desinstalación/compilación/vinculación de programas
# ===============================================================
#
# Instalación desde código fuente:
#     ./configure [--prefix=<path>] && make && make install
#
#     También se podría usar "checkinstall" para crear un paquete y evitar
#     compilar en una futura instalación.
#
# Desinstalar un programa instalado desde código fuente:
#     ./configure && make && sudo make install
#
#     Hay que abrir el directorio del código fuente desde donde
#     se instaló y hacer:
#         make uninstall
#
#     Y para limpiar residuos:
#         make clean
#
#     Nota: Puede que el programa no disponga de `uninstall`.
#
# Mostrar dependencias de bibliotecas compartidas en ejecutable con
# vinculación dinámica:
#     ldd <binary_file>
#
# Mostrar todos los enlaces dinámicos del sistema:
#     ldconfig -v | less
#
# Instalación de paquetes
# -----------------------
#
# Instalar un paquete Debian:
#     dpkg -i <package>
#
# Instalar un paquete RPM:
#     rpm -Uvh <package>
#
# Instalar un paquete con apt:
#     apt install <package>
#
# Instalar un paquete con aptitude:
#     aptitude install <package>
#
# Comprobar con aptitude si un paquete está instalado:
#     aptitude show <package>
#
# Comprobar con apt-cache si un paquete está instalado y qué versiones hay
# disponibles:
#     apt-cache policy <package>
#
# Instalar dependencias de paquetes rotos:
#     sudo aptitude install -f
#
#
# Varios
# ======
#
# Dividir un archivo MP3 en trozos a partir de un archivo CUE:
#     mp3splt -c <input_file>.cue -d <dir_output> <input_file>.mp3
#
# Calculadora:
#     bc
#
# Calendario:
#     cal
#
# Fecha actual:
#     date
#
#     Se pueden usar varios formatos:
#         date '+%F'
#         =>
#         2014-09-15
#
#         date '+%Y%m%d'
#         =>
#         20140915
#
#         date '+%y%m%d'
#         =>
#         140915
#
#         date '+%b %d'
#         =>
#         abr 15
#
# Tabla de símbolos ASCII:
#     man ascii
#
# Crear un volcado hexadecimal de un archivo o salida estándar:
#     xxd <filename>
#
# Crear una imagen ISO de DVD:
#     dd if=/dev/dvd of=<dir_path>/<image.iso>
#
# Crear una imagen ISO 9660 a partir de un directorio:
#     genisoimage -r -J -o <image.iso> <dir_path>
#
# Imprimir una secuencia de números. Con la opción `-w` rellena con ceros:
#     seq [-w] <first> <increment> <last>
#
#     Ejemplos:
#
#         seq 2
#         =>
#         1
#         2
#
#         seq 0 2
#         =>
#         0
#         1
#         2
#
#         seq 0 2 4
#         =>
#         0
#         2
#         4
#
#         seq -w 10 | xargs echo
#         =>
#         01 02 03 04 05 06 07 08 09 10
#
# Saltar a cualquier directorio del sistema:
#     z <dirname>
#
#     Web: https://github.com/rupa/z
#     Nota: Requiere que el usuario haya accedido a ese directorio en el pasado
#           con el comando `cd`.
#
# Copiar en el portapapeles el contenido de un archivo:
#     xclip -sel clip < <file>
#
#  Crear una pareja de claves pública/privada RSA con OpenSSH:
#     ssh-keygen -t rsa -b <key_size> -C "<comment>"
#
# Enviar un email:
#     echo "cuerpo del mensaje" | mail -s "asunto" <email_address>
#
# Imprimir con formato:
#     printf "My username is: $LOGNAME\nMy personal directory is: $HOME\n"
#
# Ejecutar un script desde consola o importarlo (como el #include de C) desde
# un script. También se puede usar '.' en lugar de `source`:
#     source <script>
#
# Imprimir variables de entorno:
#     env
#
# Utilidad equivalente a grep, pero con la salida en color:
#     ack-grep
#
# Cambiar el comportamiento del buffer en operaciones de entrada/salida.
# Por ejemplo, al escribir en un archivo, el SO usa un buffer de
# de escritura, lo que hace que si al mismo tiempo se visualiza cómo
# cambia el contenido del archivo en tiempo real con "tail -f", la
# información no se muestra de forma continua. Esto no ocurre cuando se
# imprime la salida de un comando en la pantalla. En ese caso no se usa
# buffer y la información se muestra de forma continua.
#
#     Sintaxis para no usar buffer en la salida:
#         stdbuf -oL <command>
#
#     Ejemplos:
#         tail -f access.log | stdbuf -oL cat
#         tail -f access.log | stdbuf -oL cut -d ' ' -f1 | uniq
#
# Visualizar un archivo JSON formateado:
#     cat data.json | jq
#
#     Otra alternativa:
#         cat data.json | json_pp
#
#
# Documentación de referencia
# ===========================
#
# [1] https://www.gnu.org/software/bash/manual/html_node/index.html
# [2] https://www.gnu.org/software/bash/manual/html_node/Command-Grouping.html
# [3] https://www.gnu.org/software/bash/manual/html_node/Redirections.html
# [4] https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/
